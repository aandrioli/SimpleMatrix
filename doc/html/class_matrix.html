<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SimpleMatrix: Matrix&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SimpleMatrix
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_matrix.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_matrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Matrix&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Basic <a class="el" href="class_matrix.html" title="Basic Matrix template class.">Matrix</a> template class.  
 <a href="class_matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="matrix_8h_source.html">matrix.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9d567e3a121b1be0c3f9c461cab524fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a9d567e3a121b1be0c3f9c461cab524fe">Matrix</a> ()</td></tr>
<tr class="memdesc:a9d567e3a121b1be0c3f9c461cab524fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs empty matrix.  <a href="class_matrix.html#a9d567e3a121b1be0c3f9c461cab524fe">More...</a><br /></td></tr>
<tr class="separator:a9d567e3a121b1be0c3f9c461cab524fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab829dc851f8fcafee35a729a31457d73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ab829dc851f8fcafee35a729a31457d73">Matrix</a> (const <a class="el" href="class_matrix.html">Matrix</a> &amp;other)</td></tr>
<tr class="memdesc:ab829dc851f8fcafee35a729a31457d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construct.  <a href="class_matrix.html#ab829dc851f8fcafee35a729a31457d73">More...</a><br /></td></tr>
<tr class="separator:ab829dc851f8fcafee35a729a31457d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ecc135681764bbb4c039de7238e5b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a20ecc135681764bbb4c039de7238e5b0">Matrix</a> (unsigned int rows, unsigned int columns, const T *values=NULL)</td></tr>
<tr class="memdesc:a20ecc135681764bbb4c039de7238e5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_matrix.html#a20ecc135681764bbb4c039de7238e5b0">More...</a><br /></td></tr>
<tr class="separator:a20ecc135681764bbb4c039de7238e5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91aa704de674203e96aece9e1955ccd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a91aa704de674203e96aece9e1955ccd3">~Matrix</a> ()</td></tr>
<tr class="memdesc:a91aa704de674203e96aece9e1955ccd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="class_matrix.html#a91aa704de674203e96aece9e1955ccd3">More...</a><br /></td></tr>
<tr class="separator:a91aa704de674203e96aece9e1955ccd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a6a8ef7ef422d23417c0092868c106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a91a6a8ef7ef422d23417c0092868c106">set</a> (unsigned int row, unsigned int col, T val)</td></tr>
<tr class="memdesc:a91a6a8ef7ef422d23417c0092868c106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set one matrix element.  <a href="class_matrix.html#a91a6a8ef7ef422d23417c0092868c106">More...</a><br /></td></tr>
<tr class="separator:a91a6a8ef7ef422d23417c0092868c106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f56b3f033ad875de459e851a533d0a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a90f56b3f033ad875de459e851a533d0a">get</a> (unsigned int row, unsigned int col) const</td></tr>
<tr class="memdesc:a90f56b3f033ad875de459e851a533d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one matrix element.  <a href="class_matrix.html#a90f56b3f033ad875de459e851a533d0a">More...</a><br /></td></tr>
<tr class="separator:a90f56b3f033ad875de459e851a533d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dfd5fa6bb8fd0b2369269360e6da9c"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a16dfd5fa6bb8fd0b2369269360e6da9c">operator[]</a> (unsigned int i)</td></tr>
<tr class="memdesc:a16dfd5fa6bb8fd0b2369269360e6da9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index operator.  <a href="class_matrix.html#a16dfd5fa6bb8fd0b2369269360e6da9c">More...</a><br /></td></tr>
<tr class="separator:a16dfd5fa6bb8fd0b2369269360e6da9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c05e54f94107ad6f20926cae08f433b"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a2c05e54f94107ad6f20926cae08f433b">size</a> () const</td></tr>
<tr class="memdesc:a2c05e54f94107ad6f20926cae08f433b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the matrix.  <a href="class_matrix.html#a2c05e54f94107ad6f20926cae08f433b">More...</a><br /></td></tr>
<tr class="separator:a2c05e54f94107ad6f20926cae08f433b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b6beafdb4d88e45b1f3b6dd4926f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a66b6beafdb4d88e45b1f3b6dd4926f76">addInPlace</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a66b6beafdb4d88e45b1f3b6dd4926f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace addition, add 'other' to current matrix.  <a href="class_matrix.html#a66b6beafdb4d88e45b1f3b6dd4926f76">More...</a><br /></td></tr>
<tr class="separator:a66b6beafdb4d88e45b1f3b6dd4926f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e010a846d76746e2cf94540adf96f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a7e010a846d76746e2cf94540adf96f5e">operator+</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a7e010a846d76746e2cf94540adf96f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">addition operator  <a href="class_matrix.html#a7e010a846d76746e2cf94540adf96f5e">More...</a><br /></td></tr>
<tr class="separator:a7e010a846d76746e2cf94540adf96f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3e1101e52a915c3e6a10fb23f67d0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a0a3e1101e52a915c3e6a10fb23f67d0c">multiplyInPlace</a> (T scalar)</td></tr>
<tr class="memdesc:a0a3e1101e52a915c3e6a10fb23f67d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">inplace multiplication  <a href="class_matrix.html#a0a3e1101e52a915c3e6a10fb23f67d0c">More...</a><br /></td></tr>
<tr class="separator:a0a3e1101e52a915c3e6a10fb23f67d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1cf341d498190e42a588557c698b8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#afe1cf341d498190e42a588557c698b8b">operator*</a> (const T scalar)</td></tr>
<tr class="memdesc:afe1cf341d498190e42a588557c698b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">inplace multiplication operator  <a href="class_matrix.html#afe1cf341d498190e42a588557c698b8b">More...</a><br /></td></tr>
<tr class="separator:afe1cf341d498190e42a588557c698b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641e4f7d262aec49b49ef9f1d95ba5bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a641e4f7d262aec49b49ef9f1d95ba5bf">operator*</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a641e4f7d262aec49b49ef9f1d95ba5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication operator  <a href="class_matrix.html#a641e4f7d262aec49b49ef9f1d95ba5bf">More...</a><br /></td></tr>
<tr class="separator:a641e4f7d262aec49b49ef9f1d95ba5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e9ed51cb7bbd9d6bdd1a23f61f9206"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a13e9ed51cb7bbd9d6bdd1a23f61f9206">hadamardInPlace</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a13e9ed51cb7bbd9d6bdd1a23f61f9206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hadamard operation.  <a href="class_matrix.html#a13e9ed51cb7bbd9d6bdd1a23f61f9206">More...</a><br /></td></tr>
<tr class="separator:a13e9ed51cb7bbd9d6bdd1a23f61f9206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a9c4017bcc835f97a3534fe7c03ca7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ae2a9c4017bcc835f97a3534fe7c03ca7">hadamard</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:ae2a9c4017bcc835f97a3534fe7c03ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hadamard operation.  <a href="class_matrix.html#ae2a9c4017bcc835f97a3534fe7c03ca7">More...</a><br /></td></tr>
<tr class="separator:ae2a9c4017bcc835f97a3534fe7c03ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82f83ae2b3b6d70210bf0c83401ee2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ae82f83ae2b3b6d70210bf0c83401ee2f">transposeInPlace</a> ()</td></tr>
<tr class="memdesc:ae82f83ae2b3b6d70210bf0c83401ee2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace transpose.  <a href="class_matrix.html#ae82f83ae2b3b6d70210bf0c83401ee2f">More...</a><br /></td></tr>
<tr class="separator:ae82f83ae2b3b6d70210bf0c83401ee2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86cb7b257ff8aacf44ea42e94b5099f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#aa86cb7b257ff8aacf44ea42e94b5099f">transpose</a> ()</td></tr>
<tr class="memdesc:aa86cb7b257ff8aacf44ea42e94b5099f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose the current matrix.  <a href="class_matrix.html#aa86cb7b257ff8aacf44ea42e94b5099f">More...</a><br /></td></tr>
<tr class="separator:aa86cb7b257ff8aacf44ea42e94b5099f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa756826b9d533a0dfc22548a76bc3e54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#aa756826b9d533a0dfc22548a76bc3e54">operator=</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:aa756826b9d533a0dfc22548a76bc3e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment operator  <a href="class_matrix.html#aa756826b9d533a0dfc22548a76bc3e54">More...</a><br /></td></tr>
<tr class="separator:aa756826b9d533a0dfc22548a76bc3e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b0a26f1f4ccabc7e243ba265b7ccad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a15b0a26f1f4ccabc7e243ba265b7ccad">operator==</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a15b0a26f1f4ccabc7e243ba265b7ccad"><td class="mdescLeft">&#160;</td><td class="mdescRight">equality operator  <a href="class_matrix.html#a15b0a26f1f4ccabc7e243ba265b7ccad">More...</a><br /></td></tr>
<tr class="separator:a15b0a26f1f4ccabc7e243ba265b7ccad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5215e1681dd3b9e0e6d51784f3dad720"><td class="memItemLeft" align="right" valign="top"><a id="a5215e1681dd3b9e0e6d51784f3dad720" name="a5215e1681dd3b9e0e6d51784f3dad720"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>debug</b> () const</td></tr>
<tr class="memdesc:a5215e1681dd3b9e0e6d51784f3dad720"><td class="mdescLeft">&#160;</td><td class="mdescRight">print matrix to cout, for debug purposes. <br /></td></tr>
<tr class="separator:a5215e1681dd3b9e0e6d51784f3dad720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08afc147d0a415abaf1e7e693c947895"><td class="memTemplParams" colspan="2">template&lt;class To &gt; </td></tr>
<tr class="memitem:a08afc147d0a415abaf1e7e693c947895"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_matrix.html#a08afc147d0a415abaf1e7e693c947895">convertTo</a> (<a class="el" href="class_matrix.html">Matrix</a>&lt; To &gt; &amp;out)</td></tr>
<tr class="memdesc:a08afc147d0a415abaf1e7e693c947895"><td class="mdescLeft">&#160;</td><td class="mdescRight">create duplicate matrix of with different type  <a href="class_matrix.html#a08afc147d0a415abaf1e7e693c947895">More...</a><br /></td></tr>
<tr class="separator:a08afc147d0a415abaf1e7e693c947895"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a910e3b95bd4ccf5678a42c7e0e4c8c96"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a910e3b95bd4ccf5678a42c7e0e4c8c96">add</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;first, const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;second)</td></tr>
<tr class="memdesc:a910e3b95bd4ccf5678a42c7e0e4c8c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">addition, add 'other' to current matrix, and return new result-matrix.  <a href="class_matrix.html#a910e3b95bd4ccf5678a42c7e0e4c8c96">More...</a><br /></td></tr>
<tr class="separator:a910e3b95bd4ccf5678a42c7e0e4c8c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7d538b5fc56ed95420ae727b2e82f2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a5e7d538b5fc56ed95420ae727b2e82f2">multiply</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;first, T scalar)</td></tr>
<tr class="memdesc:a5e7d538b5fc56ed95420ae727b2e82f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication with scalar  <a href="class_matrix.html#a5e7d538b5fc56ed95420ae727b2e82f2">More...</a><br /></td></tr>
<tr class="separator:a5e7d538b5fc56ed95420ae727b2e82f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675782ab685ac3cd19bb1eb89faa6cbc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a675782ab685ac3cd19bb1eb89faa6cbc">multiply</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;first, const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;second)</td></tr>
<tr class="memdesc:a675782ab685ac3cd19bb1eb89faa6cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication of two matrices  <a href="class_matrix.html#a675782ab685ac3cd19bb1eb89faa6cbc">More...</a><br /></td></tr>
<tr class="separator:a675782ab685ac3cd19bb1eb89faa6cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class Matrix&lt; T &gt;</div><p >Basic <a class="el" href="class_matrix.html" title="Basic Matrix template class.">Matrix</a> template class. </p>
<p >Very basic <a class="el" href="class_matrix.html" title="Basic Matrix template class.">Matrix</a> class for addition, multiplication and transposing of matrices. This is a template class so to declare a matrix of integers, declare: </p><div class="fragment"><div class="line"><a class="code hl_class" href="class_matrix.html">Matrix&lt;int&gt;</a> m;</div>
<div class="ttc" id="aclass_matrix_html"><div class="ttname"><a href="class_matrix.html">Matrix</a></div><div class="ttdoc">Basic Matrix template class.</div><div class="ttdef"><b>Definition:</b> matrix.h:50</div></div>
</div><!-- fragment --><p >Some operations are inplace, that is the current matrix will be updated, while other operations return new matrices, leaving the current matrix unaltered.</p>
<p >Matrices need to have the same type in order to do calculation on them. So for example a multiplication of Matrix&lt;int&gt; times Matrix&lt;float&gt; won't compile. (With an exception for convertTo, naturally)</p>
<p >Class T must have * and + operators. ConvertTo uses only standard casting. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9d567e3a121b1be0c3f9c461cab524fe" name="a9d567e3a121b1be0c3f9c461cab524fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d567e3a121b1be0c3f9c461cab524fe">&#9670;&nbsp;</a></span>Matrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;<a class="el" href="class_matrix.html">::Matrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs empty matrix. </p>
<p >Normally you create only an empty matrix if you want to store the result of a matrix calculation in it later. </p>

</div>
</div>
<a id="ab829dc851f8fcafee35a729a31457d73" name="ab829dc851f8fcafee35a729a31457d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab829dc851f8fcafee35a729a31457d73">&#9670;&nbsp;</a></span>Matrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;<a class="el" href="class_matrix.html">::Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy construct. </p>
<p >Create new matrix based on the parameter. The matrix given by the parameter will be (deep) copied, so you really end up having to separate matrices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the matrix to be copied from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20ecc135681764bbb4c039de7238e5b0" name="a20ecc135681764bbb4c039de7238e5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ecc135681764bbb4c039de7238e5b0">&#9670;&nbsp;</a></span>Matrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;<a class="el" href="class_matrix.html">::Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>values</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p >Create a new matrix based on the given dimensions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>the number of rows of the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">columns</td><td>the number of columns of the matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>optional: an 1-dimensional array with the matrix values stored from left to right and top to bottom. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91aa704de674203e96aece9e1955ccd3" name="a91aa704de674203e96aece9e1955ccd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91aa704de674203e96aece9e1955ccd3">&#9670;&nbsp;</a></span>~Matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::~<a class="el" href="class_matrix.html">Matrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>
<p >Free the memory in use by this matrix </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a910e3b95bd4ccf5678a42c7e0e4c8c96" name="a910e3b95bd4ccf5678a42c7e0e4c8c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910e3b95bd4ccf5678a42c7e0e4c8c96">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>addition, add 'other' to current matrix, and return new result-matrix. </p>
<p >Matrices must have he same dimensions for an addition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>the first matrix to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>the second matrix to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new result-matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>thrown matrix dimension don't match. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66b6beafdb4d88e45b1f3b6dd4926f76" name="a66b6beafdb4d88e45b1f3b6dd4926f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b6beafdb4d88e45b1f3b6dd4926f76">&#9670;&nbsp;</a></span>addInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::addInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inplace addition, add 'other' to current matrix. </p>
<p >Matrices must have he same dimensions for an addition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the matrix to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>thrown matrix dimension don't match. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08afc147d0a415abaf1e7e693c947895" name="a08afc147d0a415abaf1e7e693c947895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08afc147d0a415abaf1e7e693c947895">&#9670;&nbsp;</a></span>convertTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class To &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::convertTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a>&lt; To &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create duplicate matrix of with different type </p>
<p >Create duplicate but with different type. So, you can for example convert int matrices to float matrices usage: matrixa.convertTo(matrixOut), where matrixOut is the matrix where the data is copied to. Type conversion is just done by typecasting!! (No rounding)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>the new matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90f56b3f033ad875de459e851a533d0a" name="a90f56b3f033ad875de459e851a533d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f56b3f033ad875de459e851a533d0a">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get one matrix element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>the row position of the element to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>the column position of the element to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the requested element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>thrown when row or col is out of bounds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2a9c4017bcc835f97a3534fe7c03ca7" name="ae2a9c4017bcc835f97a3534fe7c03ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a9c4017bcc835f97a3534fe7c03ca7">&#9670;&nbsp;</a></span>hadamard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::hadamard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hadamard operation. </p>
<p >Hadamard (element-wise) product. Returns new result matrix. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the second matrix to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return new matrix with the result of the hadamard product of this*other </dd></dl>

</div>
</div>
<a id="a13e9ed51cb7bbd9d6bdd1a23f61f9206" name="a13e9ed51cb7bbd9d6bdd1a23f61f9206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e9ed51cb7bbd9d6bdd1a23f61f9206">&#9670;&nbsp;</a></span>hadamardInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::hadamardInPlace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hadamard operation. </p>
<p >Hadamard (element-wise) product. Executed inplace. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the second matrix to multiply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a675782ab685ac3cd19bb1eb89faa6cbc" name="a675782ab685ac3cd19bb1eb89faa6cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675782ab685ac3cd19bb1eb89faa6cbc">&#9670;&nbsp;</a></span>multiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>multiplication of two matrices </p>
<p >Multiplication of two matrices: first*second </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>the first matrix to multiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>the second matrix to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return new matrix with the result of first*second </dd></dl>

</div>
</div>
<a id="a5e7d538b5fc56ed95420ae727b2e82f2" name="a5e7d538b5fc56ed95420ae727b2e82f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7d538b5fc56ed95420ae727b2e82f2">&#9670;&nbsp;</a></span>multiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>multiplication with scalar </p>
<p >Multiplication of a matrix with a scalar </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>the matrix to multiply </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>the multiplication factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return new matrix with the result of first*scalar </dd></dl>

</div>
</div>
<a id="a0a3e1101e52a915c3e6a10fb23f67d0c" name="a0a3e1101e52a915c3e6a10fb23f67d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3e1101e52a915c3e6a10fb23f67d0c">&#9670;&nbsp;</a></span>multiplyInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::multiplyInPlace </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inplace multiplication </p>
<p >inplace multiplication with scalar, multiply every element with 'scalar' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scalar</td><td>the multiplication factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a641e4f7d262aec49b49ef9f1d95ba5bf" name="a641e4f7d262aec49b49ef9f1d95ba5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641e4f7d262aec49b49ef9f1d95ba5bf">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>multiplication operator </p>
<p >Multiplication of two matrices: this*other </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the second matrix to multiply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return new matrix with the result of this*other </dd></dl>

</div>
</div>
<a id="afe1cf341d498190e42a588557c698b8b" name="afe1cf341d498190e42a588557c698b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1cf341d498190e42a588557c698b8b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inplace multiplication operator </p>
<p >See <a class="el" href="class_matrix.html#a0a3e1101e52a915c3e6a10fb23f67d0c" title="inplace multiplication">multiplyInPlace()</a> </p>

</div>
</div>
<a id="a7e010a846d76746e2cf94540adf96f5e" name="a7e010a846d76746e2cf94540adf96f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e010a846d76746e2cf94540adf96f5e">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>addition operator </p>
<p >For convenience calls </p><div class="fragment"><div class="line"><a class="code hl_function" href="class_matrix.html#a910e3b95bd4ccf5678a42c7e0e4c8c96">Matrix::add</a>(first, second)</div>
<div class="ttc" id="aclass_matrix_html_a910e3b95bd4ccf5678a42c7e0e4c8c96"><div class="ttname"><a href="class_matrix.html#a910e3b95bd4ccf5678a42c7e0e4c8c96">Matrix::add</a></div><div class="ttdeci">static Matrix&lt; T &gt; add(const Matrix&lt; T &gt; &amp;first, const Matrix&lt; T &gt; &amp;second)</div><div class="ttdoc">addition, add 'other' to current matrix, and return new result-matrix.</div><div class="ttdef"><b>Definition:</b> matrix.h:245</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa756826b9d533a0dfc22548a76bc3e54" name="aa756826b9d533a0dfc22548a76bc3e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa756826b9d533a0dfc22548a76bc3e54">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assignment operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the matrix to copy into this </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15b0a26f1f4ccabc7e243ba265b7ccad" name="a15b0a26f1f4ccabc7e243ba265b7ccad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b0a26f1f4ccabc7e243ba265b7ccad">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>equality operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>the matrix to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true is matrices are equal </dd></dl>

</div>
</div>
<a id="a16dfd5fa6bb8fd0b2369269360e6da9c" name="a16dfd5fa6bb8fd0b2369269360e6da9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16dfd5fa6bb8fd0b2369269360e6da9c">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index operator. </p>
<p >Returns an array with the matrix-row. As this is a regular array, it can be indexed again. So <br  />
 </p><div class="fragment"><div class="line">A.get(1,2)</div>
</div><!-- fragment --><p> equals </p><div class="fragment"><div class="line">A[1][2]</div>
</div><!-- fragment --><p >Warning! As you get a pointer to the internal data structure of the matrix as return value, you mess the matrix up. So don't reallocate, free memory and such..</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the first (row) index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the requested row </dd></dl>

</div>
</div>
<a id="a91a6a8ef7ef422d23417c0092868c106" name="a91a6a8ef7ef422d23417c0092868c106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a6a8ef7ef422d23417c0092868c106">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set one matrix element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>the row position of the element to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col</td><td>the column position of the element to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>the value the element must be set to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">invalid_argument</td><td>thrown when row or col is out of bounds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c05e54f94107ad6f20926cae08f433b" name="a2c05e54f94107ad6f20926cae08f433b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c05e54f94107ad6f20926cae08f433b">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int * <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>an pointer to an int[2] array with the { row, col } value. </dd></dl>

</div>
</div>
<a id="aa86cb7b257ff8aacf44ea42e94b5099f" name="aa86cb7b257ff8aacf44ea42e94b5099f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86cb7b257ff8aacf44ea42e94b5099f">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transpose the current matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>A new matrix with the transposed values. </dd></dl>

</div>
</div>
<a id="ae82f83ae2b3b6d70210bf0c83401ee2f" name="ae82f83ae2b3b6d70210bf0c83401ee2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82f83ae2b3b6d70210bf0c83401ee2f">&#9670;&nbsp;</a></span>transposeInPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::transposeInPlace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inplace transpose. </p>
<p >transposes the current matrix. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="matrix_8h_source.html">matrix.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_matrix.html">Matrix</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4 </li>
  </ul>
</div>
</body>
</html>
